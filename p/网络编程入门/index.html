<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="网络编程入门 同时也算是beej‘s guide to network programming的阅读笔记， 当然这里不一定会按章原书的章节原封不动的来， 会穿插一些个人见解（囿于水平有限， 无法保证都是对的）\n前置知识 什么是socket 在unix系统中， 所有的一切都是文件，这些文件会关联一个文件描述符（其实就是一个整数， 可以理解为这些文件的id）。\n当我们在unix系统中， 使用scoket()会返回一个文件描述符（文件id）, 然后我们通过send和recv对这个文件上进行了类似write和read的操作， 以此来达到交换数据的目的\nsocket类型 网络socket是有两种类型的：\nstream dgram(DATAGRAM) 前者使用的是TCP协议(Transmission Control Protocol), TCP协议在传输过程中是要一直保证链接的， 而且数据包是有序传递的(使用telnet就是顺序传输信息的)且会是完整传递；\n相反地datagram使用的是UDP（User Datagram Protocol）， 数据不能保证是有序的， 甚至不能保证数据是完整的（当然相应的， udp的传输可以更快）。\n有些文件传输软件， 比如tftp其实用的也是udp， 但是它在udp协议的基础上又添加了一层协议，这层协议会要求接收者受到信息后返回一个信号ACK,信息发送者只有收到这个信号才能表示发送信息成功， 不然信息会被重发\nData Encapsulation 我们知道OSI（open system interconnect ）会有7个层级：\nApplication Presentation Session Transport Network Data Link Physical 每一个层级都会携带一些相应的信息，最开始用户发送的出去的信息可能就是一个简单的字符串， 这一串信息会被层层封包：\n越外层的封包信息， 越接近物理层， 为什么？因为数据的接收者， 肯定先是物理层， 比如Ethernet， wifi这些靠近物理的layer， 最后层层解包， 拿到被封装在最里面的数据data\nipv4和ipv6 ipv4地址， 诸如： 192.10.2.111, 就是4字节， 32位的地址，也就是存着2的32次方的可能性， 大概最多能表示40亿个地址。\n在互联网刚刚诞生的时候， 40亿当然是个天文数字， 但是在人均都有手机以及各种可以联网的穿戴设备的今天， 40亿有点捉襟见肘了。\nipv6则是16个字节， 也就是128位， 意味着能表示2的128种地址， 所以很显然， 即便是全宇宙的生物体都有一台能连接互联网的手机， 应该也是够够用了。\nipv6的地址： 2001:0db8:c9d2:aee5:73e3:934a:a5ae:9551\n上面每个冒号分割的都是用16进制表示的2个字节， 也就是16位(16 * 8刚好就是128) 在ipv6在表示上， 为了更简便， 可以压缩每个冒号分割中靠前面的0， 比如上面的0db8这部分可以压缩成db8。\n类似0000:0000:0000:0000:0000:0000:0000:0001这样的地址可以直接被压缩位::1,这个就是相当于ipv4中locahost， 即127.0.0.1 。 另外ipv4是可以转化位ipv6， 转化规则并没有我们想象中的需要牵涉到进制的转化，而是直接在ipv4地址的基础上加上前缀， 比如地址192.0.2.33可以转化位 ::ffff:192.0.2.33\n"><title>网络编程入门</title>
<link rel=canonical href=https://superjcd.github.io/p/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/><link rel=stylesheet href=/scss/style.min.0304c6baf04e01a8fe70693791cb744d56a3578a3120a8796cefc66825aa39c7.css><meta property='og:title' content="网络编程入门"><meta property='og:description' content="网络编程入门 同时也算是beej‘s guide to network programming的阅读笔记， 当然这里不一定会按章原书的章节原封不动的来， 会穿插一些个人见解（囿于水平有限， 无法保证都是对的）\n前置知识 什么是socket 在unix系统中， 所有的一切都是文件，这些文件会关联一个文件描述符（其实就是一个整数， 可以理解为这些文件的id）。\n当我们在unix系统中， 使用scoket()会返回一个文件描述符（文件id）, 然后我们通过send和recv对这个文件上进行了类似write和read的操作， 以此来达到交换数据的目的\nsocket类型 网络socket是有两种类型的：\nstream dgram(DATAGRAM) 前者使用的是TCP协议(Transmission Control Protocol), TCP协议在传输过程中是要一直保证链接的， 而且数据包是有序传递的(使用telnet就是顺序传输信息的)且会是完整传递；\n相反地datagram使用的是UDP（User Datagram Protocol）， 数据不能保证是有序的， 甚至不能保证数据是完整的（当然相应的， udp的传输可以更快）。\n有些文件传输软件， 比如tftp其实用的也是udp， 但是它在udp协议的基础上又添加了一层协议，这层协议会要求接收者受到信息后返回一个信号ACK,信息发送者只有收到这个信号才能表示发送信息成功， 不然信息会被重发\nData Encapsulation 我们知道OSI（open system interconnect ）会有7个层级：\nApplication Presentation Session Transport Network Data Link Physical 每一个层级都会携带一些相应的信息，最开始用户发送的出去的信息可能就是一个简单的字符串， 这一串信息会被层层封包：\n越外层的封包信息， 越接近物理层， 为什么？因为数据的接收者， 肯定先是物理层， 比如Ethernet， wifi这些靠近物理的layer， 最后层层解包， 拿到被封装在最里面的数据data\nipv4和ipv6 ipv4地址， 诸如： 192.10.2.111, 就是4字节， 32位的地址，也就是存着2的32次方的可能性， 大概最多能表示40亿个地址。\n在互联网刚刚诞生的时候， 40亿当然是个天文数字， 但是在人均都有手机以及各种可以联网的穿戴设备的今天， 40亿有点捉襟见肘了。\nipv6则是16个字节， 也就是128位， 意味着能表示2的128种地址， 所以很显然， 即便是全宇宙的生物体都有一台能连接互联网的手机， 应该也是够够用了。\nipv6的地址： 2001:0db8:c9d2:aee5:73e3:934a:a5ae:9551\n上面每个冒号分割的都是用16进制表示的2个字节， 也就是16位(16 * 8刚好就是128) 在ipv6在表示上， 为了更简便， 可以压缩每个冒号分割中靠前面的0， 比如上面的0db8这部分可以压缩成db8。\n类似0000:0000:0000:0000:0000:0000:0000:0001这样的地址可以直接被压缩位::1,这个就是相当于ipv4中locahost， 即127.0.0.1 。 另外ipv4是可以转化位ipv6， 转化规则并没有我们想象中的需要牵涉到进制的转化，而是直接在ipv4地址的基础上加上前缀， 比如地址192.0.2.33可以转化位 ::ffff:192.0.2.33\n"><meta property='og:url' content='https://superjcd.github.io/p/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/'><meta property='og:site_name' content='superjcd'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='socket编程'><meta property='article:published_time' content='2024-01-01T00:00:00+00:00'><meta property='article:modified_time' content='2024-01-01T00:00:00+00:00'><meta name=twitter:title content="网络编程入门"><meta name=twitter:description content="网络编程入门 同时也算是beej‘s guide to network programming的阅读笔记， 当然这里不一定会按章原书的章节原封不动的来， 会穿插一些个人见解（囿于水平有限， 无法保证都是对的）\n前置知识 什么是socket 在unix系统中， 所有的一切都是文件，这些文件会关联一个文件描述符（其实就是一个整数， 可以理解为这些文件的id）。\n当我们在unix系统中， 使用scoket()会返回一个文件描述符（文件id）, 然后我们通过send和recv对这个文件上进行了类似write和read的操作， 以此来达到交换数据的目的\nsocket类型 网络socket是有两种类型的：\nstream dgram(DATAGRAM) 前者使用的是TCP协议(Transmission Control Protocol), TCP协议在传输过程中是要一直保证链接的， 而且数据包是有序传递的(使用telnet就是顺序传输信息的)且会是完整传递；\n相反地datagram使用的是UDP（User Datagram Protocol）， 数据不能保证是有序的， 甚至不能保证数据是完整的（当然相应的， udp的传输可以更快）。\n有些文件传输软件， 比如tftp其实用的也是udp， 但是它在udp协议的基础上又添加了一层协议，这层协议会要求接收者受到信息后返回一个信号ACK,信息发送者只有收到这个信号才能表示发送信息成功， 不然信息会被重发\nData Encapsulation 我们知道OSI（open system interconnect ）会有7个层级：\nApplication Presentation Session Transport Network Data Link Physical 每一个层级都会携带一些相应的信息，最开始用户发送的出去的信息可能就是一个简单的字符串， 这一串信息会被层层封包：\n越外层的封包信息， 越接近物理层， 为什么？因为数据的接收者， 肯定先是物理层， 比如Ethernet， wifi这些靠近物理的layer， 最后层层解包， 拿到被封装在最里面的数据data\nipv4和ipv6 ipv4地址， 诸如： 192.10.2.111, 就是4字节， 32位的地址，也就是存着2的32次方的可能性， 大概最多能表示40亿个地址。\n在互联网刚刚诞生的时候， 40亿当然是个天文数字， 但是在人均都有手机以及各种可以联网的穿戴设备的今天， 40亿有点捉襟见肘了。\nipv6则是16个字节， 也就是128位， 意味着能表示2的128种地址， 所以很显然， 即便是全宇宙的生物体都有一台能连接互联网的手机， 应该也是够够用了。\nipv6的地址： 2001:0db8:c9d2:aee5:73e3:934a:a5ae:9551\n上面每个冒号分割的都是用16进制表示的2个字节， 也就是16位(16 * 8刚好就是128) 在ipv6在表示上， 为了更简便， 可以压缩每个冒号分割中靠前面的0， 比如上面的0db8这部分可以压缩成db8。\n类似0000:0000:0000:0000:0000:0000:0000:0001这样的地址可以直接被压缩位::1,这个就是相当于ipv4中locahost， 即127.0.0.1 。 另外ipv4是可以转化位ipv6， 转化规则并没有我们想象中的需要牵涉到进制的转化，而是直接在ipv4地址的基础上加上前缀， 比如地址192.0.2.33可以转化位 ::ffff:192.0.2.33\n"><link rel="shortcut icon" href=/favicon.ico></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu12125167938935615648.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>🍥</span></figure><div class=site-meta><h1 class=site-name><a href=/>superjcd</a></h1><h2 class=site-description></h2></div></header><ol class=menu-social><li><a href=https://github.com/superjcd target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/links/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>Links</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#前置知识>前置知识</a><ol><li><a href=#什么是socket>什么是socket</a></li><li><a href=#socket类型>socket类型</a></li><li><a href=#data-encapsulation>Data Encapsulation</a></li><li><a href=#ipv4和ipv6>ipv4和ipv6</a></li><li><a href=#subnets子网>subnets子网</a></li><li><a href=#字节顺序>字节顺序</a></li></ol></li><li><a href=#应用1-查找ip地址>应用1-查找ip地址</a><ol><li><a href=#代码>代码</a></li><li><a href=#说明>说明</a></li></ol></li><li><a href=#应用2-使用scoket进行网络传输>应用2-使用scoket进行网络传输</a><ol><li><a href=#代码-1>代码</a></li><li><a href=#说明-1>说明</a></li></ol></li><li><a href=#应用3---简单的server--client实现>应用3 - 简单的server & client实现</a><ol><li><a href=#server端>server端</a></li><li><a href=#client端>client端</a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/%E7%BD%91%E7%BB%9C/>网络</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/>网络编程入门</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Jan 01, 2024</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>5 minute read</time></div></footer></div></header><section class=article-content><h1 id=网络编程入门>网络编程入门</h1><p>同时也算是<a class=link href=https://beej.us/guide/bgnet/html/split/index.html target=_blank rel=noopener>beej‘s guide to network programming</a>的阅读笔记，
当然这里不一定会按章原书的章节原封不动的来， 会穿插一些个人见解（囿于水平有限， 无法保证都是对的）</p><h2 id=前置知识>前置知识</h2><h3 id=什么是socket>什么是socket</h3><p>在unix系统中， 所有的一切都是文件，这些文件会关联一个文件描述符（其实就是一个整数， 可以理解为这些文件的id）。<br>当我们在unix系统中， 使用scoket()会返回一个文件描述符（文件id）, 然后我们通过send和recv对这个文件上进行了类似write和read的操作，
以此来达到交换数据的目的</p><h3 id=socket类型>socket类型</h3><p>网络socket是有两种类型的：</p><ul><li>stream</li><li>dgram(DATAGRAM)</li></ul><p>前者使用的是TCP协议(Transmission Control Protocol), TCP协议在传输过程中是要一直保证链接的， 而且数据包是有序传递的(使用telnet就是顺序传输信息的)且会是完整传递；<br>相反地datagram使用的是UDP（User Datagram Protocol）， 数据不能保证是有序的， 甚至不能保证数据是完整的（当然相应的， udp的传输可以更快）。</p><blockquote><p>有些文件传输软件， 比如tftp其实用的也是udp， 但是它在udp协议的基础上又添加了一层协议，这层协议会要求接收者受到信息后返回一个信号ACK,信息发送者只有收到这个信号才能表示发送信息成功， 不然信息会被重发</p></blockquote><h3 id=data-encapsulation>Data Encapsulation</h3><p>我们知道OSI（open system interconnect ）会有7个层级：</p><ul><li>Application</li><li>Presentation</li><li>Session</li><li>Transport</li><li>Network</li><li>Data Link</li><li>Physical</li></ul><p>每一个层级都会携带一些相应的信息，最开始用户发送的出去的信息可能就是一个简单的字符串， 这一串信息会被层层封包：</p><p><img src=/p/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/imgs/1.png width=369 height=254 srcset="/p/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/imgs/1_hu12280765021840289042.png 480w, /p/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/imgs/1_hu15843395510608055003.png 1024w" loading=lazy class=gallery-image data-flex-grow=145 data-flex-basis=348px></p><p>越外层的封包信息， 越接近物理层， 为什么？因为数据的接收者， 肯定先是物理层， 比如Ethernet， wifi这些靠近物理的layer， 最后层层解包， 拿到被封装在最里面的数据data</p><h3 id=ipv4和ipv6>ipv4和ipv6</h3><p>ipv4地址， 诸如： 192.10.2.111, 就是4字节， 32位的地址，也就是存着2的32次方的可能性， 大概最多能表示40亿个地址。<br>在互联网刚刚诞生的时候， 40亿当然是个天文数字， 但是在人均都有手机以及各种可以联网的穿戴设备的今天， 40亿有点捉襟见肘了。<br>ipv6则是16个字节， 也就是128位， 意味着能表示2的128种地址， 所以很显然， 即便是全宇宙的生物体都有一台能连接互联网的手机， 应该也是够够用了。<br>ipv6的地址： 2001:0db8:c9d2:aee5:73e3:934a:a5ae:9551<br>上面每个冒号分割的都是用16进制表示的2个字节， 也就是16位(16 * 8刚好就是128)
在ipv6在表示上， 为了更简便， 可以压缩每个冒号分割中靠前面的0， 比如上面的0db8这部分可以压缩成db8。<br>类似0000:0000:0000:0000:0000:0000:0000:0001这样的地址可以直接被压缩位::1,这个就是相当于ipv4中locahost， 即127.0.0.1 。
另外ipv4是可以转化位ipv6， 转化规则并没有我们想象中的需要牵涉到进制的转化，而是直接在ipv4地址的基础上加上前缀， 比如地址192.0.2.33可以转化位 ::ffff:192.0.2.33</p><h3 id=subnets子网>subnets子网</h3><p>通常我们会把ip地址拆分成所谓network部分和host部分，假设我们的netmask是255.255.255.0
，然后我们的ip地址是192.0.2.33， 那么这个地址的network部分就是192.0.2.0， 这个值就是子掩码和ip地址执行逻辑与的结果。<br>一种更为灵活的表示方法是将ip地址直接表示为192.0.2.33/24 （也就是netmask是255.255.255.0）， ipv6也是同理</p><h3 id=字节顺序>字节顺序</h3><p>字节序有两种， 一种是大端（Big-Endian）另外一种是小端（Little-Endian），大端字节序通常会把最有效位存储在较低的地址， 小端则相反。<br>比如大端会把一个10进制数字100中的1， 先存储在内存的较低的位置。<br>由于网络基本上是大端存储的， 而很多操作系统又是小端的， 所以在信息传输的过程中自然会涉及到字节序的转换。<br>比如函数htons()， 这个函数就是用来把host的short格式的数据转化成network的short格式</p><h2 id=应用1-查找ip地址>应用1-查找ip地址</h2><h3 id=代码>代码</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>** showip.c -- show IP addresses for a host given on the command line
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/socket.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;netdb.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;arpa/inet.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;netinet/in.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>addrinfo</span> <span class=n>hints</span><span class=p>,</span> <span class=o>*</span><span class=n>res</span><span class=p>,</span> <span class=o>*</span><span class=n>p</span><span class=p>;</span>                  <span class=c1>// 1 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>status</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>ipstr</span><span class=p>[</span><span class=n>INET6_ADDRSTRLEN</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>argc</span> <span class=o>!=</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;usage: showip hostname</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>memset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>hints</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span> <span class=n>hints</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>hints</span><span class=p>.</span><span class=n>ai_family</span> <span class=o>=</span> <span class=n>AF_UNSPEC</span><span class=p>;</span>                      <span class=c1>// 2
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>hints</span><span class=p>.</span><span class=n>ai_socktype</span> <span class=o>=</span> <span class=n>SOCK_STREAM</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>status</span> <span class=o>=</span> <span class=nf>getaddrinfo</span><span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=nb>NULL</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>hints</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>res</span><span class=p>))</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>   <span class=c1>// 3 
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;getaddrinfo: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>gai_strerror</span><span class=p>(</span><span class=n>status</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;IP addresses for %s:</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>p</span> <span class=o>=</span> <span class=n>res</span><span class=p>;</span><span class=n>p</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>;</span> <span class=n>p</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>ai_next</span><span class=p>)</span> <span class=p>{</span>   <span class=c1>// 4 
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>void</span> <span class=o>*</span><span class=n>addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>char</span> <span class=o>*</span><span class=n>ipver</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// get the pointer to the address itself,
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// different fields in IPv4 and IPv6:
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>ai_family</span> <span class=o>==</span> <span class=n>AF_INET</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// IPv4
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>struct</span> <span class=n>sockaddr_in</span> <span class=o>*</span><span class=n>ipv4</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=n>sockaddr_in</span> <span class=o>*</span><span class=p>)</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>ai_addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>addr</span> <span class=o>=</span> <span class=o>&amp;</span><span class=p>(</span><span class=n>ipv4</span><span class=o>-&gt;</span><span class=n>sin_addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>ipver</span> <span class=o>=</span> <span class=s>&#34;IPv4&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span> <span class=c1>// IPv6
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>struct</span> <span class=n>sockaddr_in6</span> <span class=o>*</span><span class=n>ipv6</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=n>sockaddr_in6</span> <span class=o>*</span><span class=p>)</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>ai_addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>addr</span> <span class=o>=</span> <span class=o>&amp;</span><span class=p>(</span><span class=n>ipv6</span><span class=o>-&gt;</span><span class=n>sin6_addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>ipver</span> <span class=o>=</span> <span class=s>&#34;IPv6&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// convert the IP to a string and print it:
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>inet_ntop</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>ai_family</span><span class=p>,</span> <span class=n>addr</span><span class=p>,</span> <span class=n>ipstr</span><span class=p>,</span> <span class=k>sizeof</span> <span class=n>ipstr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;  %s: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>ipver</span><span class=p>,</span> <span class=n>ipstr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>freeaddrinfo</span><span class=p>(</span><span class=n>res</span><span class=p>);</span> <span class=c1>// free the linked list
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=说明>说明</h3><blockquote><p>说明的数值标识对应代码后面的数字注释</p></blockquote><ol><li>addrinfo是一个特殊的结构体， 结构体的签名如下：</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>addrinfo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span>              <span class=n>ai_flags</span><span class=p>;</span>     <span class=c1>// AI_PASSIVE, AI_CANONNAME, etc.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span>              <span class=n>ai_family</span><span class=p>;</span>    <span class=c1>// AF_INET, AF_INET6, AF_UNSPEC
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span>              <span class=n>ai_socktype</span><span class=p>;</span>  <span class=c1>// SOCK_STREAM, SOCK_DGRAM
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span>              <span class=n>ai_protocol</span><span class=p>;</span>  <span class=c1>// use 0 for &#34;any&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>size_t</span>           <span class=n>ai_addrlen</span><span class=p>;</span>   <span class=c1>// size of ai_addr in bytes
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=n>ai_addr</span><span class=p>;</span>      <span class=c1>// struct sockaddr_in or _in6
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>char</span>            <span class=o>*</span><span class=n>ai_canonname</span><span class=p>;</span> <span class=c1>// full canonical hostname
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>addrinfo</span> <span class=o>*</span><span class=n>ai_next</span><span class=p>;</span>      <span class=c1>// linked list, next node
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>可以看到addrinfo除了会包含一些和网络地址， socket 类型等基础信息之外， 还有一个指向下一个地址的指针（ai_next）， ai_addr是一个指向sockaddr结构体的指针：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>sockaddr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>short</span>    <span class=n>sa_family</span><span class=p>;</span>    <span class=c1>// address family, AF_xxx
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>char</span>              <span class=n>sa_data</span><span class=p>[</span><span class=mi>14</span><span class=p>];</span>  <span class=c1>// 14 bytes of protocol address
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span> 
</span></span></code></pre></td></tr></table></div></div><p>sa_data当然存储的是协议地址， 在实际代码编写的时候我们会使用sockaddr_in(ip4地址)或者sockaddr_in6(ipv6)， 然后转化为sockaddr， 这里一sockaddr_in为例， 它的结构是：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>sockaddr_in</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>short</span> <span class=kt>int</span>          <span class=n>sin_family</span><span class=p>;</span>  <span class=c1>// Address family, AF_INET
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>short</span> <span class=kt>int</span> <span class=n>sin_port</span><span class=p>;</span>    <span class=c1>// Port number
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>in_addr</span>     <span class=n>sin_addr</span><span class=p>;</span>    <span class=c1>// Internet address
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>char</span>      <span class=n>sin_zero</span><span class=p>[</span><span class=mi>8</span><span class=p>];</span> <span class=c1>// Same size as struct sockaddr
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>上面的sin_family就是个枚举值，和addrinfo的ai_family的值其实是一致的。
然后是上面的in_addr：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>in_addr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>s_addr</span><span class=p>;</span> <span class=c1>// that&#39;s a 32-bit int (4 bytes)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>然后in_addr就是个4字节的地址信息（ipv4地址）</p><ol start=2><li>这里我们没有限定是IPV4还是IPV6, 如果想要限定， 可以通过AF_INET， AF_INET6来限定IPV4或IPV6</li><li>getaddrinfo会返回一个整数值， 如果该值为0， 标识运行成功， 不然就是有错误</li></ol><blockquote><p>这里插一句： go语言的错误处理机制从某种意义上来讲， 沿袭了c语言， 也就是直接返回错误， 让调用者决定如何处理， 而不是抛出异常的这种java/python的方式</p></blockquote><ol start=4><li>这里我们进入了一个for循环， 前面我们有提及addrinfo本质上是一个链表，它有一个指向下一个addrinfo的指针， 我们不断循环获取addr地址， 然后用这个地址去获取ip地址的字符串（inet_ntop中的ntop实际为 network to presentation）</li></ol><h2 id=应用2-使用scoket进行网络传输>应用2-使用scoket进行网络传输</h2><p>使用socket进行通行， 通常会牵涉到两个角色：</p><ul><li>接受信号的， 我们称之为server服务端</li><li>发送信号的， 我们称之为client客户端
server既然是接受信号的， 涉及的流程通常会有listen（监听）和recv（接受数据， 如果是udp的话就是recvto）
client主要是发送信号的， 所以他通常会涉及connect（链接）和send（传送， 如果是udp的话就是sendto）
上面所有的操作首先是需要围绕调用socket函数返回的套接字描述符(socket descriptor)展开的</li></ul><h3 id=代码-1>代码</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/socket.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;netdb.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define MYPORT &#34;3490&#34;  </span><span class=c1>// the port users will be connecting to
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define BACKLOG 10     </span><span class=c1>// how many pending connections queue will hold
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>sockaddr_storage</span> <span class=n>their_addr</span><span class=p>;</span>    
</span></span><span class=line><span class=cl>    <span class=kt>socklen_t</span> <span class=n>addr_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>addrinfo</span> <span class=n>hints</span><span class=p>,</span> <span class=o>*</span><span class=n>res</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>sockfd</span><span class=p>,</span> <span class=n>new_fd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// !! don&#39;t forget your error checking for these calls !!
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// first, load up address structs with getaddrinfo():
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=nf>memset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>hints</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span> <span class=n>hints</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>hints</span><span class=p>.</span><span class=n>ai_family</span> <span class=o>=</span> <span class=n>AF_UNSPEC</span><span class=p>;</span>  <span class=c1>// use IPv4 or IPv6, whichever
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>hints</span><span class=p>.</span><span class=n>ai_socktype</span> <span class=o>=</span> <span class=n>SOCK_STREAM</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>hints</span><span class=p>.</span><span class=n>ai_flags</span> <span class=o>=</span> <span class=n>AI_PASSIVE</span><span class=p>;</span>     <span class=c1>//  1 
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=nf>getaddrinfo</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=n>MYPORT</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>hints</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>res</span><span class=p>);</span>   
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// make a socket, bind it, and listen on it:
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>sockfd</span> <span class=o>=</span> <span class=nf>socket</span><span class=p>(</span><span class=n>res</span><span class=o>-&gt;</span><span class=n>ai_family</span><span class=p>,</span> <span class=n>res</span><span class=o>-&gt;</span><span class=n>ai_socktype</span><span class=p>,</span> <span class=n>res</span><span class=o>-&gt;</span><span class=n>ai_protocol</span><span class=p>);</span> <span class=c1>// 2
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>bind</span><span class=p>(</span><span class=n>sockfd</span><span class=p>,</span> <span class=n>res</span><span class=o>-&gt;</span><span class=n>ai_addr</span><span class=p>,</span> <span class=n>res</span><span class=o>-&gt;</span><span class=n>ai_addrlen</span><span class=p>);</span>     <span class=c1>// 3
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>listen</span><span class=p>(</span><span class=n>sockfd</span><span class=p>,</span> <span class=n>BACKLOG</span><span class=p>);</span>                         <span class=c1>// 4
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// now accept an incoming connection:
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>addr_size</span> <span class=o>=</span> <span class=k>sizeof</span> <span class=n>their_addr</span><span class=p>;</span> <span class=err>、、</span> <span class=mi>5</span>
</span></span><span class=line><span class=cl>    <span class=n>new_fd</span> <span class=o>=</span> <span class=nf>accept</span><span class=p>(</span><span class=n>sockfd</span><span class=p>,</span> <span class=p>(</span><span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>their_addr</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>addr_size</span><span class=p>);</span> <span class=c1>//5 
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// ready to communicate on socket descriptor new_fd!
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>.</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=说明-1>说明</h3><ol><li>使用AI_PASSIVE作为我们ai_flags就是告诉程序我要绑定本机的ip， 这也就是是为什getaddrinfo的第一个参数可以是空的， 因为我是server，所以不需要特定的server name，</li><li>这里调用了socket函数， 返回一个套接字描述符， socket的三个参数， ai_family就是前面提到的ipv4或者ipv6， sockettype是前面提到的SOCKETSTREAM（tcp协议）或者SOCKETDGRAM（udp协议）</li><li>bind使用了socket返回的描述符号， 然后会bind到一个具体的port</li><li>然后server调用liste开启监听， BACKLOG是一个常量用来控制能同事监听的最大数量(其实就是限制了监听队列的大小)</li><li>accept其实就是把客户端的connect给accept的意思，然后accept会返回一个全新的套接字描述符号， 这个新的描述符就是后续用来send</li></ol><h2 id=应用3---简单的server--client实现>应用3 - 简单的server & client实现</h2><p>完整代码的话， 直接参考：https://beej.us/guide/bgnet/html/split/client-server-background.html</p><h3 id=server端>server端</h3><p>整体的server的运行流程还是遵循了前面提到的几个关键点：</p><ul><li>geraddtrinfo获取ip地址信息</li><li>socket 建立一个套接字链接返回socket descriptor</li><li>bind 绑定特定port</li><li>listen 监听</li><li>accept 接受一个incomming connection</li><li>send 通过socket发送信息</li></ul><p>不过这里为了同时处理更多的链接， 会用fork开启一个子进程：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// main accept() loop
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>sin_size</span> <span class=o>=</span> <span class=k>sizeof</span> <span class=n>their_addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>new_fd</span> <span class=o>=</span> <span class=nf>accept</span><span class=p>(</span><span class=n>sockfd</span><span class=p>,</span> <span class=p>(</span><span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>their_addr</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>sin_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>new_fd</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;accept&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nf>inet_ntop</span><span class=p>(</span><span class=n>their_addr</span><span class=p>.</span><span class=n>ss_family</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nf>get_in_addr</span><span class=p>((</span><span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>their_addr</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=n>s</span><span class=p>,</span> <span class=k>sizeof</span> <span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;server: got connection from %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>fork</span><span class=p>())</span> <span class=p>{</span> <span class=c1>// this is the child process
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nf>close</span><span class=p>(</span><span class=n>sockfd</span><span class=p>);</span> <span class=c1>// child doesn&#39;t need the listener
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=p>(</span><span class=nf>send</span><span class=p>(</span><span class=n>new_fd</span><span class=p>,</span> <span class=s>&#34;Hello, world!&#34;</span><span class=p>,</span> <span class=mi>13</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;send&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=nf>close</span><span class=p>(</span><span class=n>new_fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nf>close</span><span class=p>(</span><span class=n>new_fd</span><span class=p>);</span>  <span class=c1>// parent doesn&#39;t need this
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><blockquote><p>fork在成功开启子进程的时候， 返回值是0， 所以 !0 就是true; 但是这里没有fork失败的处理逻辑</p></blockquote><p>因为用到了子进程， 自然需要有子进程的垃圾回收</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>    <span class=n>sa</span><span class=p>.</span><span class=n>sa_handler</span> <span class=o>=</span> <span class=n>sigchld_handler</span><span class=p>;</span> <span class=c1>// reap all dead processes
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>sigemptyset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sa</span><span class=p>.</span><span class=n>sa_mask</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>sa</span><span class=p>.</span><span class=n>sa_flags</span> <span class=o>=</span> <span class=n>SA_RESTART</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>sigaction</span><span class=p>(</span><span class=n>SIGCHLD</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>sa</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;sigaction&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>当主进程通过<code>sigaction</code>获取到了SIGCHLD这个信号的时候， 会触发函数sigchld_handler来进行GC：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>sigchld_handler</span><span class=p>(</span><span class=kt>int</span> <span class=n>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// waitpid() might overwrite errno, so we save and restore it:
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>saved_errno</span> <span class=o>=</span> <span class=n>errno</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=nf>waitpid</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>WNOHANG</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>errno</span> <span class=o>=</span> <span class=n>saved_errno</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=client端>client端</h3><p>client的代码会比较简单， 它的流程和server有少许不一样：</p><ul><li>getaddrinfo， 不过作为client，我的第一个参数是需要指定server name的</li><li>socket</li><li>connect</li><li>recv， 和服务端需要使用accept返回的新的socket descriptor来发送信息， client直接用socket返回的desciptor就可以接受信息了
That&rsquo;s it</li></ul></section><footer class=article-footer><section class=article-tags><a href=/tags/socket%E7%BC%96%E7%A8%8B/>Socket编程</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><div id=gitalk-container></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css><script src=https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js></script><script src=https://cdn.jsdelivr.net/npm/blueimp-md5@2.18.0/js/md5.min.js></script><script>const gitalk=new Gitalk({clientID:"4cde8442733ac793019a",clientSecret:"06b853952b0075feb92709fa5e11392338d176d9",repo:"comments",owner:"superjcd",admin:["superjcd"],distractionFreeMode:!1,id:md5(location.pathname)});(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("gitalk-container").innerHTML="Gitalk comments not available by default when the website is previewed locally.";return}gitalk.render("gitalk-container")})()</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2025 superjcd</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.26.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>